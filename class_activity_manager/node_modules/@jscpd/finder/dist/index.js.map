{"version":3,"sources":["/Users/Andrii_Kucherenko/Workspace/lab/jscpd/packages/finder/dist/index.js","../src/in-files-detector.ts","../src/validators/skip-local.validator.ts","../src/files.ts","../src/hooks/blamer.ts","../src/hooks/fragment.ts","../src/utils/clone-found.ts","../src/utils/reports.ts","../src/subscribers/progress.ts","../src/subscribers/verbose.ts","../src/reporters/console.ts","../src/reporters/console-full.ts","../src/reporters/json.ts","../src/reporters/csv.ts","../src/reporters/markdown.ts","../src/reporters/xml.ts","../src/reporters/silent.ts","../src/reporters/threshold.ts","../src/reporters/xcode.ts","../src/utils/options.ts"],"names":["getFormatByFile","getOption","readFileSync","relative","grey","ensureDirSync","writeFileSync"],"mappings":"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","file":"/Users/Andrii_Kucherenko/Workspace/lab/jscpd/packages/finder/dist/index.js","sourcesContent":[null,"import {\n  Detector,\n  DetectorEvents,\n  IClone,\n  ICloneValidator,\n  IHandler,\n  IMapFrame,\n  IOptions,\n  IStore,\n  ISubscriber,\n  ITokenizer,\n  Statistic,\n} from '@jscpd/core';\nimport {getFormatByFile} from '@jscpd/tokenizer';\nimport {EntryWithContent, IHook, IReporter} from './interfaces';\nimport {SkipLocalValidator} from './validators';\n\nexport class InFilesDetector {\n\n  private readonly reporters: IReporter[] = [];\n  private readonly subscribes: ISubscriber[] = [];\n  private readonly postHooks: IHook[] = [];\n\n  constructor(\n    private readonly tokenizer: ITokenizer,\n    private readonly store: IStore<IMapFrame>,\n    private readonly statistic: Statistic,\n    public readonly options: IOptions) {\n    this.registerSubscriber(this.statistic);\n  }\n\n  registerReporter(reporter: IReporter): void {\n    this.reporters.push(reporter);\n  }\n\n  registerSubscriber(subscriber: ISubscriber): void {\n    this.subscribes.push(subscriber);\n  }\n\n  registerHook(hook: IHook): void {\n    this.postHooks.push(hook);\n  }\n\n  detect(fls: EntryWithContent[]): Promise<IClone[]> {\n    const files = fls.filter((f) => !!f);\n    if (files.length === 0) {\n      return Promise.resolve([]);\n    }\n    const options = this.options;\n    const hooks = [...this.postHooks];\n    const store = this.store;\n    const validators: ICloneValidator[] = [];\n\n    if (options.skipLocal) {\n      validators.push(new SkipLocalValidator());\n    }\n\n    const detector = new Detector(this.tokenizer, store, validators, options);\n\n    this.subscribes.forEach((listener: ISubscriber) => {\n      Object\n        .entries(listener.subscribe())\n        // @ts-ignore\n        .map(([event, handler]: [DetectorEvents, IHandler]) => detector.on(event, handler));\n    });\n\n    const detect = (entry: EntryWithContent, clones: IClone[] = []): Promise<IClone[]> => {\n      const {path, content} = entry;\n      const format: string|undefined = getFormatByFile(path, options.formatsExts);\n      return format !== undefined ? detector\n        .detect(path, content, format)\n        .then((clns: IClone[]) => {\n          if (clns) {\n            clones.push(...clns);\n          }\n          const file = files.pop();\n          if (file) {\n            return detect(file, clones);\n          }\n          return clones;\n        }): Promise.resolve([]);\n    };\n\n    const processHooks = (hook: IHook, detectedClones: IClone[]): Promise<IClone[]> => {\n      return hook\n        .process(detectedClones)\n        .then((clones: IClone[]) => {\n          const nextHook: IHook | undefined = hooks.pop();\n          if (nextHook) {\n            return processHooks(nextHook, clones);\n          }\n          return clones;\n        });\n    }\n\n    // @ts-ignore\n    return detect(files.pop())\n      .then((clones: IClone[]) => {\n        const hook = hooks.pop();\n        if (hook) {\n          return processHooks(hook, clones)\n        }\n        return clones;\n      })\n      .then((clones: IClone[]) => {\n        const statistic = this.statistic.getStatistic();\n        this.reporters.forEach((reporter: IReporter) => {\n          reporter.report(clones, statistic);\n        });\n        return clones;\n      });\n  }\n}\n","import {getOption, IClone, ICloneValidator, IOptions, IValidationResult} from '@jscpd/core';\nimport {isAbsolute, relative} from \"path\";\n\nexport class SkipLocalValidator implements ICloneValidator {\n\n\tvalidate(clone: IClone, options: IOptions): IValidationResult {\n\t\tconst status = !this.shouldSkipClone(clone, options);\n\t\treturn {\n\t\t\tstatus,\n\t\t\tclone,\n\t\t\tmessage: [\n\t\t\t\t`Sources of duplication located in same local folder (${clone.duplicationA.sourceId}, ${clone.duplicationB.sourceId})`\n\t\t\t]\n\t\t};\n\t}\n\n\tpublic shouldSkipClone(clone: IClone, options: IOptions): boolean {\n\t\tconst path: string[] = getOption('path', options);\n\t\treturn path.some(\n\t\t\t(dir) => SkipLocalValidator.isRelative(clone.duplicationA.sourceId, dir) && SkipLocalValidator.isRelative(clone.duplicationB.sourceId, dir)\n\t\t);\n\t}\n\n\tprivate static isRelative(file: string, path: string): boolean {\n\t\tconst rel = relative(path, file);\n\t\treturn rel !== '' && !rel.startsWith('..') && !isAbsolute(rel);\n\t}\n\n}\n","import {getOption, IOptions} from '@jscpd/core';\nimport {Entry, sync} from 'fast-glob';\nimport {getFormatByFile} from '@jscpd/tokenizer';\nimport { readFileSync, realpathSync } from 'fs-extra';\nimport {grey} from 'colors/safe';\nimport {EntryWithContent} from './interfaces';\nimport {lstatSync, Stats} from \"fs\";\nimport bytes from \"bytes\";\n\n\nfunction isFile(path: string): boolean {\n  try {\n    const stat: Stats = lstatSync(path);\n    return stat.isFile();\n  } catch (e) {\n    // lstatSync throws an error if path doesn't exist\n    return false;\n  }\n}\n\nfunction isSymlink(path: string): boolean {\n  try {\n    const stat: Stats = lstatSync(path);\n    return stat.isSymbolicLink();\n  } catch (e) {\n    // lstatSync throws an error if path doesn't exist\n    return false;\n  }\n}\n\nfunction skipNotSupportedFormats(options: IOptions): (entry: Entry) => boolean {\n  return (entry: Entry): boolean => {\n    const {path} = entry;\n    const format: string | undefined = getFormatByFile(path, options.formatsExts);\n    const shouldNotSkip = !!(format && options.format && options.format.includes(format));\n    if ((options.debug || options.verbose) && !shouldNotSkip) {\n      console.log(`File ${path} skipped! Format \"${format}\" does not included to supported formats.`);\n    }\n    return shouldNotSkip;\n  }\n}\n\nfunction skipBigFiles(options: IOptions): (entry: Entry) => boolean {\n  return (entry: Entry): boolean => {\n    const {stats, path} = entry;\n    if (!stats) {\n      return true;\n    }\n    // @ts-expect-error - stats is checked above, but DTS build doesn't recognize control flow\n    const shouldSkip = bytes.parse(stats.size) > bytes.parse(getOption('maxSize', options) || '0');\n    if (options.debug && shouldSkip) {\n      console.log(`File ${path} skipped! Size more then limit (${bytes(stats.size)} > ${getOption('maxSize', options)})`);\n    }\n    return !shouldSkip;\n  };\n}\n\nfunction skipFilesIfLinesOfContentNotInLimits(options: IOptions): (entry: EntryWithContent) => boolean {\n  return (entry: EntryWithContent): boolean => {\n    const {path, content} = entry;\n    const lines = content.split('\\n').length;\n    const minLines = getOption('minLines', options);\n    const maxLines = getOption('maxLines', options);\n    if (lines < minLines || lines > maxLines) {\n      if ((options.debug || options.verbose)) {\n        console.log(grey(`File ${path} skipped! Code lines=${lines} not in limits (${minLines}:${maxLines})`));\n      }\n      return false;\n    }\n    return true;\n  }\n}\n\nfunction addContentToEntry(entry: Entry): EntryWithContent {\n  const {path} = entry;\n  const content = readFileSync(path).toString();\n  return {...entry, content}\n}\n\nexport function getFilesToDetect(options: IOptions): EntryWithContent[] {\n  const pattern = options.pattern || '**/*';\n  let patterns = options.path;\n\n  if (options.noSymlinks) {\n    patterns = patterns!==undefined ? patterns.filter((path: string) => !isSymlink(path)) : [];\n  }\n\n  patterns = patterns!==undefined ? patterns.map((path: string) => {\n    const currentPath = realpathSync(path);\n\n    if (isFile(currentPath)) {\n      return path;\n    }\n\n    return path.endsWith('/') ? `${path}${pattern}` : `${path}/${pattern}`;\n  }): [];\n\n  return sync(\n    patterns,\n    {\n      ignore: options.ignore,\n      onlyFiles: true,\n      dot: true,\n      stats: true,\n      absolute: options.absolute || false,\n      followSymbolicLinks: !options.noSymlinks,\n      cwd: process.cwd(),\n    },\n  )\n    .filter(skipNotSupportedFormats(options))\n    .filter(skipBigFiles(options))\n    .map(addContentToEntry)\n    .filter(skipFilesIfLinesOfContentNotInLimits(options));\n}\n\n","import Blamer from 'blamer';\nimport {IBlamedLines, IClone} from '@jscpd/core';\nimport {IHook} from '..';\n\n\nexport class BlamerHook implements IHook {\n\n\tprocess(clones: IClone[]): Promise<IClone[]> {\n\t\treturn Promise.all(clones.map((clone: IClone) => BlamerHook.blameLines(clone)));\n\t}\n\n\tstatic async blameLines(clone: IClone): Promise<IClone> {\n\t\tconst blamer = new Blamer();\n\t\tconst blamedFileA: Record<string, IBlamedLines> = await blamer.blameByFile(clone.duplicationA.sourceId);\n\t\tconst blamedFileB: Record<string, IBlamedLines> = await blamer.blameByFile(clone.duplicationB.sourceId);\n\t\tclone.duplicationA.blame = BlamerHook.getBlamedLines(blamedFileA, clone.duplicationA.start.line, clone.duplicationA.end.line);\n\t\tclone.duplicationB.blame = BlamerHook.getBlamedLines(blamedFileB, clone.duplicationB.start.line, clone.duplicationB.end.line);\n\t\treturn clone;\n\t}\n\n\tstatic getBlamedLines(blamedFiles: Record<string, IBlamedLines>, start: number, end: number): IBlamedLines {\n\t\t// TODO rewrite the method\n\t\tconst [file] = Object.keys(blamedFiles);\n\t\tconst result: IBlamedLines = {};\n\t\t// @ts-ignore\n    Object.keys(blamedFiles[file])\n\t\t\t.filter((lineNumber) => {\n\t\t\t\treturn Number(lineNumber) >= start && Number(lineNumber) <= end;\n\t\t\t})\n      // @ts-ignore\n      .map((lineNumber) => blamedFiles[file][lineNumber])\n\t\t\t.forEach((info) => {\n\t\t\t\tresult[info.line] = info;\n\t\t\t});\n\t\treturn result;\n\t}\n}\n\n","import {IClone} from '@jscpd/core';\nimport {readFileSync} from \"fs\";\nimport {IHook} from '..';\n\nexport class FragmentsHook implements IHook {\n\n\tprocess(clones: IClone[]): Promise<IClone[]> {\n\t\treturn Promise.all(\n\t\t\tclones.map((clone: IClone) => FragmentsHook.addFragments(clone)),\n\t\t);\n\t}\n\n\tstatic addFragments(clone: IClone): IClone {\n\t\tconst codeA = readFileSync(clone.duplicationA.sourceId).toString();\n\t\tconst codeB = readFileSync(clone.duplicationB.sourceId).toString();\n\t\tclone.duplicationA.fragment = codeA.substring(clone.duplicationA.range[0], clone.duplicationA.range[1]);\n\t\tclone.duplicationB.fragment = codeB.substring(clone.duplicationB.range[0], clone.duplicationB.range[1]);\n\t\treturn clone;\n\t}\n\n}\n\n","import {IClone, IOptions} from '@jscpd/core';\nimport {red} from 'colors/safe';\nimport {getPathConsoleString, getSourceLocation} from './reports';\n\nexport function cloneFound(clone: IClone, options: IOptions): void {\n\tconst {duplicationA, duplicationB, format, isNew} = clone;\n\tconsole.log('Clone found (' + format + '):' + (isNew ? red('*') : ''));\n\tconsole.log(\n\t\t` - ${getPathConsoleString(duplicationA.sourceId, options)} [${getSourceLocation(\n\t\t\tduplicationA.start,\n\t\t\tduplicationA.end,\n\t\t)}] (${duplicationA.end.line - duplicationA.start.line} lines${duplicationA.end.position ? ', ' + (duplicationA.end.position - (duplicationA.start.position as number)) + ' tokens' : ''})`,\n\t);\n\tconsole.log(\n\t\t`   ${getPathConsoleString(duplicationB.sourceId, options)} [${getSourceLocation(\n\t\t\tduplicationB.start,\n\t\t\tduplicationB.end,\n\t\t)}]`,\n\t);\n\tconsole.log('');\n}\n","import {IClone, IOptions, IStatisticRow, ITokenLocation} from '@jscpd/core';\nimport {relative} from \"path\";\nimport {cwd} from \"process\";\nimport {bold, green, grey} from 'colors/safe';\n\nexport const compareDates = (firstDate: string, secondDate: string): string => {\n  const first = new Date(firstDate);\n  const second = new Date(secondDate);\n  switch (true) {\n    case first < second:\n      return '=>';\n    case first > second:\n      return '<=';\n    default:\n      return '==';\n  }\n}\n\nexport function escapeXml(unsafe: string): string {\n  return unsafe.replace(/[<>&'\"]/g, (c) => {\n    switch (c) {\n      case '<': return '&lt;';\n      case '>': return '&gt;';\n      case '&': return '&amp;';\n      case '\\'': return '&apos;';\n      case '\"': return '&quot;';\n      default: return  ''\n    }\n  });\n}\n\nexport function getPath(path: string, options: IOptions): string {\n  return options.absolute ? path : relative(cwd(), path);\n}\n\nexport function getPathConsoleString(path: string, options: IOptions): string {\n  return bold(green(getPath(path, options)));\n}\n\nexport function getSourceLocation(start: ITokenLocation, end: ITokenLocation): string {\n\treturn `${start.line}:${start.column} - ${end.line}:${end.column}`;\n}\n\nexport function generateLine(clone: IClone, position: number, line: string): string[] {\n\tconst lineNumberA: string = (clone.duplicationA.start.line + position).toString();\n\tconst lineNumberB: string = (clone.duplicationB.start.line + position).toString();\n\tif (clone.duplicationA.blame && clone.duplicationB.blame) {\n\n    return [\n\t\t\tlineNumberA,\n      // @ts-ignore\n      clone.duplicationA.blame[lineNumberA] ? clone.duplicationA.blame[lineNumberA].author : '',\n\t\t\tclone.duplicationA.blame[lineNumberA] && clone.duplicationB.blame[lineNumberB]\n        // @ts-ignore\n        ? compareDates(clone.duplicationA.blame[lineNumberA].date, clone.duplicationB.blame[lineNumberB].date)\n\t\t\t\t: '',\n\t\t\tlineNumberB,\n      // @ts-ignore\n\t\t\tclone.duplicationB.blame[lineNumberB] ? clone.duplicationB.blame[lineNumberB].author : '',\n\t\t\tgrey(line),\n\t\t];\n\t} else {\n\t\treturn [lineNumberA, lineNumberB, grey(line)];\n\t}\n}\n\nexport function convertStatisticToArray(format: string, statistic: IStatisticRow): string[] {\n  return [\n    format,\n    `${statistic.sources}`,\n    `${statistic.lines}`,\n    `${statistic.tokens}`,\n    `${statistic.clones}`,\n    `${statistic.duplicatedLines} (${statistic.percentage}%)`,\n    `${statistic.duplicatedTokens} (${statistic.percentageTokens}%)`,\n  ]\n}\n\n","import {DetectorEvents, IClone, IEventPayload, IHandler, IOptions, ISubscriber} from '@jscpd/core';\nimport {cloneFound} from '../utils/clone-found';\n\nexport class ProgressSubscriber implements ISubscriber {\n\n\tconstructor(private readonly options: IOptions) {\n\t}\n\n\tsubscribe(): Partial<Record<DetectorEvents, IHandler>> {\n\t\treturn {\n      CLONE_FOUND: (payload: IEventPayload): void => cloneFound(payload.clone as IClone, this.options),\n    };\n\t}\n}\n","import {grey, yellow} from 'colors/safe';\nimport {DetectorEvents, IEventPayload, IHandler, IOptions, ISubscriber} from '@jscpd/core';\n\nexport class VerboseSubscriber implements ISubscriber {\n\n\tconstructor(protected options: IOptions) {\n\t}\n\n\tsubscribe(): Partial<Record<DetectorEvents, IHandler>> {\n\t\treturn {\n      'CLONE_FOUND': (payload: IEventPayload): void => {\n        const {clone} = payload;\n        console.log(yellow('CLONE_FOUND'));\n        console.log(grey(JSON.stringify(clone, null, '\\t')));\n      },\n      'CLONE_SKIPPED': (payload: IEventPayload): void => {\n        const {validation} = payload;\n        console.log(yellow('CLONE_SKIPPED'));\n        console.log(\n          grey('Clone skipped: ' + validation?.message?.join(' ')),\n        );\n      },\n      'START_DETECTION': (payload: IEventPayload): void => {\n        const {source} = payload;\n        console.log(yellow('START_DETECTION'));\n        console.log(\n          grey('Start detection for source id=' + source?.getId() + ' format=' + source?.getFormat()),\n        )\n      },\n    };\n\t}\n}\n","import {IClone, IOptions, IStatistic} from '@jscpd/core';\nimport {bold, grey} from 'colors/safe';\nimport {IReporter} from '..';\nimport {convertStatisticToArray} from \"../utils/reports\";\n\nconst Table = require('cli-table3');\n\nexport class ConsoleReporter implements IReporter {\n\tprivate readonly options;\n\n\tconstructor(options: IOptions) {\n\t\tthis.options = options;\n\t}\n\n\treport(clones: IClone[], statistic: IStatistic | undefined = undefined): void {\n\t\tif (statistic && !this.options.silent) {\n\t\t\tconst table = new Table({\n        head: ['Format', 'Files analyzed', 'Total lines', 'Total tokens', 'Clones found', 'Duplicated lines', 'Duplicated tokens'],\n      });\n\n      Object.keys(statistic.formats)\n        // @ts-ignore\n        .filter((format) => statistic.formats[format].sources)\n\t\t\t\t.forEach((format: string) => {\n          // @ts-ignore\n          table.push(convertStatisticToArray(format, statistic.formats[format].total));\n\t\t\t\t});\n\t\t\ttable.push(convertStatisticToArray(bold('Total:'), statistic.total));\n\t\t\tconsole.log(table.toString());\n      console.log(grey(`Found ${clones.length} clones.`));\n\t\t}\n\t}\n}\n","import {IClone, IOptions} from '@jscpd/core';\nimport {IReporter} from '..';\nimport {generateLine} from '../utils/reports';\nimport {cloneFound} from '../utils/clone-found';\nimport {grey} from 'colors/safe';\n\nconst Table = require('cli-table3');\n\nconst TABLE_OPTIONS = {\n\tchars: {\n\t\ttop: '',\n\t\t'top-mid': '',\n\t\t'top-left': '',\n\t\t'top-right': '',\n\t\tbottom: '',\n\t\t'bottom-mid': '',\n\t\t'bottom-left': '',\n\t\t'bottom-right': '',\n\t\tleft: '',\n\t\t'left-mid': '',\n\t\tmid: '',\n\t\t'mid-mid': '',\n\t\tright: '',\n\t\t'right-mid': '',\n\t\tmiddle: 'â”‚',\n\t},\n};\n\nexport class ConsoleFullReporter implements IReporter {\n\n\tconstructor(private readonly options: IOptions) {\n\t}\n\n\tpublic report(clones: IClone[]): void {\n\t\tclones.forEach((clone: IClone) => {\n\t\t\tthis.cloneFullFound(clone);\n\t\t});\n\t\tconsole.log(grey(`Found ${clones.length} clones.`));\n\t}\n\n\tprivate cloneFullFound(clone: IClone): void {\n\t\tconst table = new Table(TABLE_OPTIONS);\n\n\t\tcloneFound(clone, this.options);\n\n    // @ts-ignore\n\t\tclone.duplicationA.fragment.split('\\n').forEach((line: string, position: number) => {\n\t\t\t(table).push(generateLine(clone, position, line));\n\t\t});\n\n\t\tconsole.log(table.toString());\n\t\tconsole.log('');\n\t}\n}\n","import {ensureDirSync, writeFileSync} from 'fs-extra';\nimport {getOption, IBlamedLines, IClone, IOptions, IStatistic, ITokenLocation} from '@jscpd/core';\nimport {getPath} from '../utils/reports';\nimport {green} from 'colors/safe';\nimport {join} from \"path\";\nimport {IReporter} from '..';\n\ninterface IDuplication {\n\tformat: string;\n\tlines: number;\n\ttokens: number;\n\tfirstFile: {\n\t\tname: string;\n\t\tstart: number;\n\t\tend: number;\n\t\tstartLoc: ITokenLocation;\n\t\tendLoc: ITokenLocation;\n\t\tblame?: IBlamedLines;\n\t};\n\tsecondFile: {\n\t\tname: string;\n\t\tstart: number;\n\t\tend: number;\n\t\tstartLoc: ITokenLocation;\n\t\tendLoc: ITokenLocation;\n\t\tblame?: IBlamedLines;\n\t};\n\tfragment: string;\n}\n\ninterface IJsonReport {\n\tduplicates: IDuplication[];\n\tstatistics: IStatistic;\n}\n\nexport class JsonReporter implements IReporter {\n\n  constructor(private options: IOptions) {\n  }\n\n  public generateJson(clones: IClone[], statistics: IStatistic): IJsonReport {\n    return {\n      statistics,\n      duplicates: clones.map(clone => this.cloneFound(clone))\n    };\n  }\n\n  public report(clones: IClone[], statistic: IStatistic): void {\n    const json = this.generateJson(clones, statistic);\n    ensureDirSync(getOption('output', this.options));\n    writeFileSync(getOption('output', this.options) + '/jscpd-report.json', JSON.stringify(json, null, '  '));\n    console.log(green(`JSON report saved to ${join(this.options.output as string, 'jscpd-report.json')}`));\n  }\n\n  private cloneFound(clone: IClone): IDuplication {\n    const startLineA = clone.duplicationA.start.line;\n    const endLineA = clone.duplicationA.end.line;\n    const startLineB = clone.duplicationB.start.line;\n    const endLineB = clone.duplicationB.end.line;\n\n    return {\n      format: clone.format,\n      lines: endLineA - startLineA + 1,\n      fragment: clone.duplicationA.fragment as string,\n      tokens: 0,\n      firstFile: {\n        name: getPath(clone.duplicationA.sourceId, this.options),\n        start: startLineA,\n        end: endLineA,\n        startLoc: clone.duplicationA.start,\n        endLoc: clone.duplicationA.end,\n        blame: clone.duplicationA.blame,\n      },\n      secondFile: {\n        name: getPath(clone.duplicationB.sourceId, this.options),\n        start: startLineB,\n        end: endLineB,\n        startLoc: clone.duplicationB.start,\n        endLoc: clone.duplicationB.end,\n        blame: clone.duplicationB.blame,\n      },\n    };\n  }\n}\n","import {IReporter} from '..';\nimport {getOption, IClone, IOptions, IStatistic} from \"@jscpd/core\";\nimport {ensureDirSync, writeFileSync} from \"fs-extra\";\nimport {green} from \"colors/safe\";\nimport {join} from \"path\";\nimport {convertStatisticToArray} from \"../utils/reports\";\n\nexport class CSVReporter implements IReporter {\n\n  constructor(private options: IOptions) {\n  }\n\n  // @ts-ignore\n  report(clones: IClone[], statistic: IStatistic | undefined): void {\n    const report = [\n      ['Format', 'Files analyzed', 'Total lines', 'Total tokens', 'Clones found', 'Duplicated lines', 'Duplicated tokens'],\n      ...Object.keys((statistic as any).formats).map((format: string) => convertStatisticToArray(format, (statistic as any).formats[format].total)),\n      convertStatisticToArray('Total:', (statistic as any).total)\n    ].map((arr) => arr.join(',')).join('\\n');\n\n    ensureDirSync(getOption('output', this.options));\n    writeFileSync(getOption('output', this.options) + '/jscpd-report.csv', report);\n    console.log(green(`CSV report saved to ${join(this.options?.output as string, 'jscpd-report.csv')}`));\n  }\n\n\n}\n","import {getOption, IClone, IOptions, IStatistic} from \"@jscpd/core\";\nimport {ensureDirSync, writeFileSync} from \"fs-extra\";\nimport {green} from \"colors/safe\";\nimport {join} from \"path\";\nimport {convertStatisticToArray} from \"../utils/reports\";\nimport {IReporter} from '..';\nimport markdownTable from \"markdown-table\";\n\nexport class MarkdownReporter implements IReporter {\n\n  constructor(private options: IOptions) {\n  }\n\n  report(clones: IClone[], statistic: IStatistic | undefined): void {\n    const report = `\n# Copy/paste detection report\n\n> Duplications detection: Found ${clones.length} exact clones with ${(statistic as any).total.duplicatedLines}(${(statistic as any).total.percentage}%) duplicated lines in ${(statistic as any).total.sources} (${Object.keys((statistic as any).formats).length} formats) files.\n\n${markdownTable([\n      ['Format', 'Files analyzed', 'Total lines', 'Total tokens', 'Clones found', 'Duplicated lines', 'Duplicated tokens'],\n      ...Object.keys((statistic as any).formats).map((format: string) => convertStatisticToArray(format, (statistic as any).formats[format].total)),\n      convertStatisticToArray('Total:', (statistic as any).total).map(item => `**${item}**`)\n    ])}\n`;\n    ensureDirSync(getOption('output', this.options));\n    writeFileSync(getOption('output', this.options) + '/jscpd-report.md', report);\n    console.log(green(`Markdown report saved to ${join(this.options.output as string, 'jscpd-report.md')}`));\n  }\n}\n","import {writeFileSync} from 'fs';\nimport {ensureDirSync} from 'fs-extra';\nimport {IReporter} from '..';\nimport {getOption, IClone, IOptions} from '@jscpd/core';\nimport {escapeXml, getPath} from '../utils/reports';\nimport {green} from 'colors/safe';\nimport {join} from \"path\";\n\nexport class XmlReporter implements IReporter {\n  constructor(private options: IOptions) {\n  }\n\n\n  public report(clones: IClone[]): void {\n    let xmlDoc = '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>';\n\n    xmlDoc += '<pmd-cpd>';\n\n    clones.forEach((clone: IClone) => {\n      xmlDoc = `${xmlDoc}\n      <duplication lines=\"${clone.duplicationA.end.line - clone.duplicationA.start.line}\">\n            <file path=\"${escapeXml(getPath(clone.duplicationA.sourceId, this.options))}\" line=\"${clone.duplicationA.start.line}\">\n              <codefragment><![CDATA[${clone.duplicationA.fragment?.replace(/]]>/i, 'CDATA_END')}]]></codefragment>\n            </file>\n            <file path=\"${escapeXml(getPath(clone.duplicationB.sourceId, this.options))}\" line=\"${clone.duplicationB.start.line}\">\n              <codefragment><![CDATA[${clone.duplicationB.fragment?.replace(/]]>/i, 'CDATA_END')}]]></codefragment>\n            </file>\n            <codefragment><![CDATA[${clone.duplicationA.fragment?.replace(/]]>/i, 'CDATA_END')}]]></codefragment>\n        </duplication>\n      `;\n\t\t});\n\t\txmlDoc += '</pmd-cpd>';\n\n\t\tensureDirSync(getOption('output', this.options));\n\t\twriteFileSync(getOption('output', this.options) + '/jscpd-report.xml', xmlDoc);\n\t\tconsole.log(green(`XML report saved to ${join(this.options.output as string, 'jscpd-report.xml')}`));\n\t}\n}\n","import {bold} from 'colors/safe';\nimport {IClone, IStatistic} from '@jscpd/core';\nimport {IReporter} from '..';\n\nexport class SilentReporter implements IReporter {\n\n\tpublic report(clones: IClone[], statistic: IStatistic): void {\n\t\tif (statistic) {\n\t\t\tconsole.log(\n\t\t\t\t`Duplications detection: Found ${bold(clones.length.toString())} ` +\n\t\t\t\t`exact clones with ${bold(statistic.total.duplicatedLines.toString())}(${statistic.total.percentage}%) ` +\n\t\t\t\t`duplicated lines in ${bold(statistic.total.sources.toString())} ` +\n\t\t\t\t`(${Object.keys(statistic.formats).length} formats) files.`,\n\t\t\t);\n\t\t}\n\t}\n}\n","import {red} from 'colors/safe';\nimport {IClone, IOptions, IStatistic} from '@jscpd/core';\nimport {IReporter} from '..';\n\nexport class ThresholdReporter implements IReporter {\n\tconstructor(private options: IOptions) {\n\t}\n\n\t// @ts-ignore\n  public report(clones: IClone[], statistic: IStatistic | undefined): void {\n    if (statistic && this.options.threshold !== undefined && this.options.threshold < statistic.total.percentage) {\n      const message = `ERROR: jscpd found too many duplicates (${statistic.total.percentage}%) over threshold (${this.options.threshold}%)`;\n      console.error(red(message));\n      throw new Error(message);\n    }\n\t}\n}\n","import {IClone, IOptions} from '@jscpd/core';\nimport {IReporter} from '..';\nimport {getPath} from '../utils/reports';\n\nexport class XcodeReporter implements IReporter {\n\tconstructor(private readonly options: IOptions) {\n\t}\n\n\tpublic report(clones: IClone[]): void {\n\t\tclones.forEach((clone: IClone) => {\n\t\t\tthis.cloneFound(clone);\n\t\t});\n\t\tconsole.log(`Found ${clones.length} clones.`);\n\t}\n\n\tprivate cloneFound(clone: IClone): void {\n\t\tconst pathA = getPath(clone.duplicationA.sourceId, {...this.options, absolute: true});\n\t\tconst pathB = getPath(clone.duplicationB.sourceId, this.options);\n\t\tconst startLineA = clone.duplicationA.start.line;\n\t\tconst characterA = clone.duplicationA.start.column;\n\t\tconst endLineA = clone.duplicationA.end.line;\n\t\tconst startLineB = clone.duplicationB.start.line;\n\t\tconst endLineB = clone.duplicationB.end.line;\n\t\tconsole.log(`${pathA}:${startLineA}:${characterA}: warning: Found ${endLineA - startLineA} lines (${startLineA}-${endLineA}) duplicated on file ${pathB} (${startLineB}-${endLineB})`);\n\t}\n}\n","export function parseFormatsExtensions(extensions = ''): { [key: string]: string[] } | undefined {\n\tconst result: { [key: string]: string[] } = {};\n\n\tif (!extensions) {\n\t\treturn undefined;\n\t}\n\n\textensions.split(';').forEach((format: string) => {\n\t\tconst pair = format.split(':');\n\t\t// @ts-ignore\n    result[pair[0]] = pair[1].split(',');\n\t});\n\n\treturn result;\n}\n"]}